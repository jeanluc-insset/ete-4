package fr.upjv.mis.ete.gel;


import fr.insset.jeanluc.util.factory.FactoryRegistry;
import fr.upjv.mis.GelLexer;
import fr.upjv.mis.GelParser;
import fr.upjv.mis.GelParser.GelExpressionContext;
import fr.upjv.mis.GelParserBaseVisitor;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CodePointCharStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTree;



/**
 * Creates an abstract tree from a gel expression.<br>
 * Uses the default Gel parser provided by antlr.
 *
 * @author jldeleage
 */
public class TreeBuilder extends GelParserBaseVisitor<GelExpression> {


    public static void initFactories() {
        FactoryRegistry registry = FactoryRegistry.getRegistry();
        // operators
#foreach ($aClass in $current.classes)
#if ($aClass.getValueOf("symbol"))
#set ($strings = $aClass.getValueOf("symbol").split(" "))
#foreach ($aSymbol in $strings)
        registry.registerDefaultFactory("$aSymbol", Gel${aClass.name}Impl.class);
#end
#end
#end
        // literals
#foreach ($aClass in $current.classes)
#if ($aClass.hasStereotype("literal"))
        registry.registerDefaultFactory("${dialect.i2lc($aClass.name)}", Gel${aClass.name}Impl.class);
#end
#end
    }


    public TreeBuilder() {
        TreeBuilder.initFactories();
    }


    public GelExpression build(String inExpression, Object inContext) {
        GelLexer lexer = null;
        CodePointCharStream input = CharStreams.fromString(inExpression);
        lexer = new GelLexer(input);
        CommonTokenStream commonTokenStream = new CommonTokenStream(lexer);
        GelParser parser = new GelParser(commonTokenStream);
        GelParser.GelExpressionContext gelExpression = parser.gelExpression();
        return visit(gelExpression);
    }


    //==========================================================================//


    @Override
    public GelExpression visit(ParseTree tree) {
        switch (((ParserRuleContext) tree).getChildCount()) {
            case 1:
                return super.visit(tree);
            case 3:
                return visitBinary((ParserRuleContext) tree);
        }
        return super.visit(tree);
    }



    //==========================================================================//


    protected GelExpression visitBinary(ParserRuleContext inContext) {
        List<ParseTree>     children = inContext.children;
        GelExpression result = visit(children.get(0));
        if (children.size() > 1) {
            try {
                GelExpression left = result;
                GelExpression right = visit(children.get(2));
                String symbol = children.get(1).getText();
                System.out.println("Visiting the binary operator " + symbol);
                result = (GelExpression) FactoryRegistry.newInstance(symbol);
                result.add${prefix}Operand(left);
                result.add${prefix}Operand(right);
            } catch (InstantiationException ex) {
                Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IllegalAccessException ex) {
                Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return result;
    }

    protected GelExpression visitHalf(ParserRuleContext inContext) {
        List<ParseTree>     children = inContext.children;
        GelExpression result;
        GelExpression right = visit(children.get(1));
        String symbol = children.get(0).getText();
        try {
            System.out.println("Visiting the \"half\" binary operator " + symbol);
            result = (GelExpression) FactoryRegistry.newInstance(symbol);
            result.add${prefix}Operand(right);
        } catch (InstantiationException ex) {
            Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

#foreach ($aClass in $current.classes)
#if ($aClass.getValueOf("symbol"))
##if (!$aClass.getValueOf("rule"))
    @Override
    public GelExpression visit${aClass.name}Expression(GelParser.${aClass.name}ExpressionContext ctx) {
#if ($aClass.getValueOf("arity").equals("2"))
        return visitBinary(ctx);
#elseif ($aClass.getValueOf("arity") == "half")
        return visitHalf(ctx);
#else
        return null;
#end
    }

##end
#end
#end

    //==========================================================================//

/*
#foreach ($aClass in $current.classes)
#if ($aClass.getValueOf("rule"))
    @Override
    public GelExpression visit${dialect.i2uc($rule)}Expression(GelParser.${dialect.i2uc($rule)}ExpressionContext ctx) {
#if ($aClass.getValueOf("arity").equals("2"))
        return visit(ctx.getChild(1));
#else
        return null;
#end
    }
    
#end
#end
*/


    //==========================================================================//


#foreach ($aClass in $current.classes)
#if ($aClass.hasStereotype("literal"))
    @Override
    public GelExpression visit${aClass.name}(GelParser.${aClass.name}Context ctx) {
        try {
            ${prefix}Literal result = (${prefix}Literal) FactoryRegistry.newInstance("${dialect.i2lc($aClass.name)}");
            result.setValue(ctx.getText());
            return result;
        } catch (InstantiationException ex) {
            Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(TreeBuilder.class.getName()).log(Level.SEVERE, null, ex);
        }
        // We should return a specific GelExpression stating the error
        return null;
    }

#end
#end


    private     Map<String, Class>      symbols = new HashMap<>();

}

